## 线性表
线性表是具有`相同数据类型`的n（n>0）个数据元素的`有限序列`,其中n为`表长`，当n = 0 时线性表是一个`空表`
$$L=(a_1,a_2,....a_n)$$
》数据元素的位序从1开始
## 顺序表
用顺序存储的方式来实现线性表 
- 逻辑相邻，物理也相邻

静态分配
```cpp
#define Maxsize 10
typedef struct
{
    int data[Maxsize];
    int length;//顺序表当前长度
}SqList;//顺序表类型定义
void Init(SqList &L)
{
    L.length=0;//无默认值，初始长度为0
}
int main()
{
    SqList L;//声明一个顺序表
    Init();
}
```
动态分配
```cpp
//使用动态数组实现
#define Initsize 10//初始长度
typedef struct
{
    int* data;
    int Maxsize;//最大容量
    int length;//顺序表当前长度
}SqList;//顺序表类型定义
void Init(SqList &L)
{
    L.data=new int[Initsize];//分配空间
//L.data=(int*)malloc(sizeof(int)*Initsize);
    L.length=0;//无默认值，初始长度为0
    L.Maxsize=Initsize;
}
void Increase(SqList&L,int len)//增加表长
{
    int *p=L.data;//临时变量指向旧空间
    L.data=new int[L.Maxsize+len];//分配新空间
//L.data=(int*)malloc((len+L.Maxsize)*sizeof(int));
    for(int i=0;i<L.length;i++)
        L.data[i]=p[i];//将数据复制到新区域
    L.Maxsize+=len;//更新最大长度
    delete []p;//释放旧空间
}
void ListInsert(SqList&L,int i,int e)//在L的位序i插入元素e
{
    for(int j=L.length;j>=i;j--)//i个元素及以后后移
        L.data[j]=L.data[j-1];
    L.data[i-1]=e;//插入e
    L.length++;//长度加1
}
bool ListFix(SqList&L,int i,int e)
{
    if(i<1||i>=L.length+1)
    {
        cout<<"不在范围内,修改无效"<<endl;
        return false;
    } 
    L.data[i-1]=e;
    return true;  
//T(n)=O(1)平均/最坏时间复杂度
}
void Display(const SqList& L,int i=0)
{
    if(i==0)
    {
        for(i=0;i<L.length;i++)
        cout<<L.data[i]<<' ';
        return;
    }
    i--;
    cout<<L.data[i]<<endl;
}
int main()
{
    SqList L;//声明一个顺序表
    Init(L);
    Increase(L,0);//增加5个长度
    ListInsert(L,1,3);//插入元素
    ListInsert(L,2,5);//插入元素
    ListInsert(L,3,7);//插入元素
    ListFix(L,0,8);//修改元素
    ListDelete(L,2,3);//删除元素
    Display(L);//显示元素
    cin.get(); 
}
//由此可见，动态分配时间开销大
```
特点
- 随机访问可以在`O(1)`时间内找到第i个元素
- 存储密度高
- 拓展容量不方便（即使能采用动态分配，但时间复杂度比较高）
- 插入删除不方便